"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-redux";
exports.ids = ["vendor-chunks/react-redux"];
exports.modules = {

/***/ "(ssr)/../../node_modules/react-redux/dist/react-redux.mjs":
/*!***********************************************************!*\
  !*** ../../node_modules/react-redux/dist/react-redux.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider_default),\n/* harmony export */   ReactReduxContext: () => (/* binding */ ReactReduxContext),\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   connect: () => (/* binding */ connect_default),\n/* harmony export */   createDispatchHook: () => (/* binding */ createDispatchHook),\n/* harmony export */   createSelectorHook: () => (/* binding */ createSelectorHook),\n/* harmony export */   createStoreHook: () => (/* binding */ createStoreHook),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual),\n/* harmony export */   useDispatch: () => (/* binding */ useDispatch),\n/* harmony export */   useSelector: () => (/* binding */ useSelector),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/with-selector.js */ \"(ssr)/../../node_modules/use-sync-external-store/with-selector.js\");\n// src/utils/react.ts\n\n// src/utils/react-is.ts\nvar IS_REACT_19 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.version.startsWith(\"19\");\nvar REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for(IS_REACT_19 ? \"react.transitional.element\" : \"react.element\");\nvar REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for(\"react.portal\");\nvar REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for(\"react.fragment\");\nvar REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for(\"react.strict_mode\");\nvar REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for(\"react.profiler\");\nvar REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for(\"react.consumer\");\nvar REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for(\"react.context\");\nvar REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for(\"react.forward_ref\");\nvar REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for(\"react.suspense\");\nvar REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for(\"react.suspense_list\");\nvar REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for(\"react.memo\");\nvar REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for(\"react.lazy\");\nvar REACT_OFFSCREEN_TYPE = /* @__PURE__ */ Symbol.for(\"react.offscreen\");\nvar REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for(\"react.client.reference\");\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nfunction isValidElementType(type) {\n    return typeof type === \"string\" || typeof type === \"function\" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || typeof type === \"object\" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) ? true : false;\n}\nfunction typeOf(object) {\n    if (typeof object === \"object\" && object !== null) {\n        const { $$typeof } = object;\n        switch($$typeof){\n            case REACT_ELEMENT_TYPE:\n                switch(object = object.type, object){\n                    case REACT_FRAGMENT_TYPE:\n                    case REACT_PROFILER_TYPE:\n                    case REACT_STRICT_MODE_TYPE:\n                    case REACT_SUSPENSE_TYPE:\n                    case REACT_SUSPENSE_LIST_TYPE:\n                        return object;\n                    default:\n                        switch(object = object && object.$$typeof, object){\n                            case REACT_CONTEXT_TYPE:\n                            case REACT_FORWARD_REF_TYPE:\n                            case REACT_LAZY_TYPE:\n                            case REACT_MEMO_TYPE:\n                                return object;\n                            case REACT_CONSUMER_TYPE:\n                                return object;\n                            default:\n                                return $$typeof;\n                        }\n                }\n            case REACT_PORTAL_TYPE:\n                return $$typeof;\n        }\n    }\n}\nfunction isContextConsumer(object) {\n    return IS_REACT_19 ? typeOf(object) === REACT_CONSUMER_TYPE : typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isMemo(object) {\n    return typeOf(object) === REACT_MEMO_TYPE;\n}\n// src/utils/warning.ts\nfunction warning(message) {\n    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(message);\n    }\n    try {\n        throw new Error(message);\n    } catch (e) {}\n}\n// src/connect/verifySubselectors.ts\nfunction verify(selector, methodName) {\n    if (!selector) {\n        throw new Error(`Unexpected value for ${methodName} in connect.`);\n    } else if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\n        if (!Object.prototype.hasOwnProperty.call(selector, \"dependsOnOwnProps\")) {\n            warning(`The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`);\n        }\n    }\n}\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n    verify(mapStateToProps, \"mapStateToProps\");\n    verify(mapDispatchToProps, \"mapDispatchToProps\");\n    verify(mergeProps, \"mergeProps\");\n}\n// src/connect/selectorFactory.ts\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, { areStatesEqual, areOwnPropsEqual, areStatePropsEqual }) {\n    let hasRunAtLeastOnce = false;\n    let state;\n    let ownProps;\n    let stateProps;\n    let dispatchProps;\n    let mergedProps;\n    function handleFirstCall(firstState, firstOwnProps) {\n        state = firstState;\n        ownProps = firstOwnProps;\n        stateProps = mapStateToProps(state, ownProps);\n        dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        hasRunAtLeastOnce = true;\n        return mergedProps;\n    }\n    function handleNewPropsAndNewState() {\n        stateProps = mapStateToProps(state, ownProps);\n        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleNewProps() {\n        if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleNewState() {\n        const nextStateProps = mapStateToProps(state, ownProps);\n        const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n        stateProps = nextStateProps;\n        if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleSubsequentCalls(nextState, nextOwnProps) {\n        const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n        const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);\n        state = nextState;\n        ownProps = nextOwnProps;\n        if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n        if (propsChanged) return handleNewProps();\n        if (stateChanged) return handleNewState();\n        return mergedProps;\n    }\n    return function pureFinalPropsSelector(nextState, nextOwnProps) {\n        return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n    };\n}\nfunction finalPropsSelectorFactory(dispatch, { initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options }) {\n    const mapStateToProps = initMapStateToProps(dispatch, options);\n    const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n    const mergeProps = initMergeProps(dispatch, options);\n    if (true) {\n        verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\n    }\n    return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n// src/utils/bindActionCreators.ts\nfunction bindActionCreators(actionCreators, dispatch) {\n    const boundActionCreators = {};\n    for(const key in actionCreators){\n        const actionCreator = actionCreators[key];\n        if (typeof actionCreator === \"function\") {\n            boundActionCreators[key] = (...args)=>dispatch(actionCreator(...args));\n        }\n    }\n    return boundActionCreators;\n}\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null) return false;\n    const proto = Object.getPrototypeOf(obj);\n    if (proto === null) return true;\n    let baseProto = proto;\n    while(Object.getPrototypeOf(baseProto) !== null){\n        baseProto = Object.getPrototypeOf(baseProto);\n    }\n    return proto === baseProto;\n}\n// src/utils/verifyPlainObject.ts\nfunction verifyPlainObject(value, displayName, methodName) {\n    if (!isPlainObject(value)) {\n        warning(`${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`);\n    }\n}\n// src/connect/wrapMapToProps.ts\nfunction wrapMapToPropsConstant(getConstant) {\n    return function initConstantSelector(dispatch) {\n        const constant = getConstant(dispatch);\n        function constantSelector() {\n            return constant;\n        }\n        constantSelector.dependsOnOwnProps = false;\n        return constantSelector;\n    };\n}\nfunction getDependsOnOwnProps(mapToProps) {\n    return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n}\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n    return function initProxySelector(dispatch, { displayName }) {\n        const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n            return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);\n        };\n        proxy.dependsOnOwnProps = true;\n        proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n            proxy.mapToProps = mapToProps;\n            proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n            let props = proxy(stateOrDispatch, ownProps);\n            if (typeof props === \"function\") {\n                proxy.mapToProps = props;\n                proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n                props = proxy(stateOrDispatch, ownProps);\n            }\n            if (true) verifyPlainObject(props, displayName, methodName);\n            return props;\n        };\n        return proxy;\n    };\n}\n// src/connect/invalidArgFactory.ts\nfunction createInvalidArgFactory(arg, name) {\n    return (dispatch, options)=>{\n        throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`);\n    };\n}\n// src/connect/mapDispatchToProps.ts\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n    return mapDispatchToProps && typeof mapDispatchToProps === \"object\" ? wrapMapToPropsConstant((dispatch)=>// @ts-ignore\n        bindActionCreators(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch)=>({\n            dispatch\n        })) : typeof mapDispatchToProps === \"function\" ? // @ts-ignore\n    wrapMapToPropsFunc(mapDispatchToProps, \"mapDispatchToProps\") : createInvalidArgFactory(mapDispatchToProps, \"mapDispatchToProps\");\n}\n// src/connect/mapStateToProps.ts\nfunction mapStateToPropsFactory(mapStateToProps) {\n    return !mapStateToProps ? wrapMapToPropsConstant(()=>({})) : typeof mapStateToProps === \"function\" ? // @ts-ignore\n    wrapMapToPropsFunc(mapStateToProps, \"mapStateToProps\") : createInvalidArgFactory(mapStateToProps, \"mapStateToProps\");\n}\n// src/connect/mergeProps.ts\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n    return {\n        ...ownProps,\n        ...stateProps,\n        ...dispatchProps\n    };\n}\nfunction wrapMergePropsFunc(mergeProps) {\n    return function initMergePropsProxy(dispatch, { displayName, areMergedPropsEqual }) {\n        let hasRunOnce = false;\n        let mergedProps;\n        return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n            const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n            if (hasRunOnce) {\n                if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n            } else {\n                hasRunOnce = true;\n                mergedProps = nextMergedProps;\n                if (true) verifyPlainObject(mergedProps, displayName, \"mergeProps\");\n            }\n            return mergedProps;\n        };\n    };\n}\nfunction mergePropsFactory(mergeProps) {\n    return !mergeProps ? ()=>defaultMergeProps : typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, \"mergeProps\");\n}\n// src/utils/batch.ts\nfunction defaultNoopBatch(callback) {\n    callback();\n}\n// src/utils/Subscription.ts\nfunction createListenerCollection() {\n    let first = null;\n    let last = null;\n    return {\n        clear () {\n            first = null;\n            last = null;\n        },\n        notify () {\n            defaultNoopBatch(()=>{\n                let listener = first;\n                while(listener){\n                    listener.callback();\n                    listener = listener.next;\n                }\n            });\n        },\n        get () {\n            const listeners = [];\n            let listener = first;\n            while(listener){\n                listeners.push(listener);\n                listener = listener.next;\n            }\n            return listeners;\n        },\n        subscribe (callback) {\n            let isSubscribed = true;\n            const listener = last = {\n                callback,\n                next: null,\n                prev: last\n            };\n            if (listener.prev) {\n                listener.prev.next = listener;\n            } else {\n                first = listener;\n            }\n            return function unsubscribe() {\n                if (!isSubscribed || first === null) return;\n                isSubscribed = false;\n                if (listener.next) {\n                    listener.next.prev = listener.prev;\n                } else {\n                    last = listener.prev;\n                }\n                if (listener.prev) {\n                    listener.prev.next = listener.next;\n                } else {\n                    first = listener.next;\n                }\n            };\n        }\n    };\n}\nvar nullListeners = {\n    notify () {},\n    get: ()=>[]\n};\nfunction createSubscription(store, parentSub) {\n    let unsubscribe;\n    let listeners = nullListeners;\n    let subscriptionsAmount = 0;\n    let selfSubscribed = false;\n    function addNestedSub(listener) {\n        trySubscribe();\n        const cleanupListener = listeners.subscribe(listener);\n        let removed = false;\n        return ()=>{\n            if (!removed) {\n                removed = true;\n                cleanupListener();\n                tryUnsubscribe();\n            }\n        };\n    }\n    function notifyNestedSubs() {\n        listeners.notify();\n    }\n    function handleChangeWrapper() {\n        if (subscription.onStateChange) {\n            subscription.onStateChange();\n        }\n    }\n    function isSubscribed() {\n        return selfSubscribed;\n    }\n    function trySubscribe() {\n        subscriptionsAmount++;\n        if (!unsubscribe) {\n            unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n            listeners = createListenerCollection();\n        }\n    }\n    function tryUnsubscribe() {\n        subscriptionsAmount--;\n        if (unsubscribe && subscriptionsAmount === 0) {\n            unsubscribe();\n            unsubscribe = void 0;\n            listeners.clear();\n            listeners = nullListeners;\n        }\n    }\n    function trySubscribeSelf() {\n        if (!selfSubscribed) {\n            selfSubscribed = true;\n            trySubscribe();\n        }\n    }\n    function tryUnsubscribeSelf() {\n        if (selfSubscribed) {\n            selfSubscribed = false;\n            tryUnsubscribe();\n        }\n    }\n    const subscription = {\n        addNestedSub,\n        notifyNestedSubs,\n        handleChangeWrapper,\n        isSubscribed,\n        trySubscribe: trySubscribeSelf,\n        tryUnsubscribe: tryUnsubscribeSelf,\n        getListeners: ()=>listeners\n    };\n    return subscription;\n}\n// src/utils/useIsomorphicLayoutEffect.ts\nvar canUseDOM = ()=>!!( false && 0);\nvar isDOM = /* @__PURE__ */ canUseDOM();\nvar isRunningInReactNative = ()=>typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\nvar isReactNative = /* @__PURE__ */ isRunningInReactNative();\nvar getUseIsomorphicLayoutEffect = ()=>isDOM || isReactNative ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();\n// src/utils/shallowEqual.ts\nfunction is(x, y) {\n    if (x === y) {\n        return x !== 0 || y !== 0 || 1 / x === 1 / y;\n    } else {\n        return x !== x && y !== y;\n    }\n}\nfunction shallowEqual(objA, objB) {\n    if (is(objA, objB)) return true;\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false;\n    }\n    const keysA = Object.keys(objA);\n    const keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) return false;\n    for(let i = 0; i < keysA.length; i++){\n        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\n// src/utils/hoistStatics.ts\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextType: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    getDerivedStateFromError: true,\n    getDerivedStateFromProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    callee: true,\n    arguments: true,\n    arity: true\n};\nvar FORWARD_REF_STATICS = {\n    $$typeof: true,\n    render: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true\n};\nvar MEMO_STATICS = {\n    $$typeof: true,\n    compare: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true,\n    type: true\n};\nvar TYPE_STATICS = {\n    [ForwardRef]: FORWARD_REF_STATICS,\n    [Memo]: MEMO_STATICS\n};\nfunction getStatics(component) {\n    if (isMemo(component)) {\n        return MEMO_STATICS;\n    }\n    return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent) {\n    if (typeof sourceComponent !== \"string\") {\n        if (objectPrototype) {\n            const inheritedComponent = getPrototypeOf(sourceComponent);\n            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                hoistNonReactStatics(targetComponent, inheritedComponent);\n            }\n        }\n        let keys = getOwnPropertyNames(sourceComponent);\n        if (getOwnPropertySymbols) {\n            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n        }\n        const targetStatics = getStatics(targetComponent);\n        const sourceStatics = getStatics(sourceComponent);\n        for(let i = 0; i < keys.length; ++i){\n            const key = keys[i];\n            if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n                const descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                try {\n                    defineProperty(targetComponent, key, descriptor);\n                } catch (e) {}\n            }\n        }\n    }\n    return targetComponent;\n}\n// src/components/Context.ts\nvar ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);\nvar gT = typeof globalThis !== \"undefined\" ? globalThis : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */ {};\nfunction getContext() {\n    if (!react__WEBPACK_IMPORTED_MODULE_0__.createContext) return {};\n    const contextMap = gT[ContextKey] ??= /* @__PURE__ */ new Map();\n    let realContext = contextMap.get(react__WEBPACK_IMPORTED_MODULE_0__.createContext);\n    if (!realContext) {\n        realContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n        if (true) {\n            realContext.displayName = \"ReactRedux\";\n        }\n        contextMap.set(react__WEBPACK_IMPORTED_MODULE_0__.createContext, realContext);\n    }\n    return realContext;\n}\nvar ReactReduxContext = /* @__PURE__ */ getContext();\n// src/components/connect.tsx\nvar NO_SUBSCRIPTION_ARRAY = [\n    null,\n    null\n];\nvar stringifyComponent = (Comp)=>{\n    try {\n        return JSON.stringify(Comp);\n    } catch (err) {\n        return String(Comp);\n    }\n};\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n    useIsomorphicLayoutEffect(()=>effectFunc(...effectArgs), dependencies);\n}\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n    lastWrapperProps.current = wrapperProps;\n    renderIsScheduled.current = false;\n    if (childPropsFromStoreUpdate.current) {\n        childPropsFromStoreUpdate.current = null;\n        notifyNestedSubs();\n    }\n}\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\n    if (!shouldHandleStateChanges) return ()=>{};\n    let didUnsubscribe = false;\n    let lastThrownError = null;\n    const checkForUpdates = ()=>{\n        if (didUnsubscribe || !isMounted.current) {\n            return;\n        }\n        const latestStoreState = store.getState();\n        let newChildProps, error;\n        try {\n            newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n        } catch (e) {\n            error = e;\n            lastThrownError = e;\n        }\n        if (!error) {\n            lastThrownError = null;\n        }\n        if (newChildProps === lastChildProps.current) {\n            if (!renderIsScheduled.current) {\n                notifyNestedSubs();\n            }\n        } else {\n            lastChildProps.current = newChildProps;\n            childPropsFromStoreUpdate.current = newChildProps;\n            renderIsScheduled.current = true;\n            additionalSubscribeListener();\n        }\n    };\n    subscription.onStateChange = checkForUpdates;\n    subscription.trySubscribe();\n    checkForUpdates();\n    const unsubscribeWrapper = ()=>{\n        didUnsubscribe = true;\n        subscription.tryUnsubscribe();\n        subscription.onStateChange = null;\n        if (lastThrownError) {\n            throw lastThrownError;\n        }\n    };\n    return unsubscribeWrapper;\n}\nfunction strictEqual(a, b) {\n    return a === b;\n}\nvar hasWarnedAboutDeprecatedPureOption = false;\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps, { // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n// @ts-ignore\npure, areStatesEqual = strictEqual, areOwnPropsEqual = shallowEqual, areStatePropsEqual = shallowEqual, areMergedPropsEqual = shallowEqual, // use React's forwardRef to expose a ref of the wrapped component\nforwardRef = false, // the context consumer to use\ncontext = ReactReduxContext } = {}) {\n    if (true) {\n        if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {\n            hasWarnedAboutDeprecatedPureOption = true;\n            warning('The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component');\n        }\n    }\n    const Context = context;\n    const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n    const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n    const initMergeProps = mergePropsFactory(mergeProps);\n    const shouldHandleStateChanges = Boolean(mapStateToProps);\n    const wrapWithConnect = (WrappedComponent)=>{\n        if (true) {\n            const isValid = /* @__PURE__ */ isValidElementType(WrappedComponent);\n            if (!isValid) throw new Error(`You must pass a component to the function returned by connect. Instead received ${stringifyComponent(WrappedComponent)}`);\n        }\n        const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n        const displayName = `Connect(${wrappedComponentName})`;\n        const selectorFactoryOptions = {\n            shouldHandleStateChanges,\n            displayName,\n            wrappedComponentName,\n            WrappedComponent,\n            // @ts-ignore\n            initMapStateToProps,\n            initMapDispatchToProps,\n            initMergeProps,\n            areStatesEqual,\n            areStatePropsEqual,\n            areOwnPropsEqual,\n            areMergedPropsEqual\n        };\n        function ConnectFunction(props) {\n            const [propsContext, reactReduxForwardedRef, wrapperProps] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;\n                return [\n                    props.context,\n                    reactReduxForwardedRef2,\n                    wrapperProps2\n                ];\n            }, [\n                props\n            ]);\n            const ContextToUse = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                let ResultContext = Context;\n                if (propsContext?.Consumer) {\n                    if (true) {\n                        const isValid = /* @__PURE__ */ isContextConsumer(// @ts-ignore\n                        /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(propsContext.Consumer, null));\n                        if (!isValid) {\n                            throw new Error(\"You must pass a valid React context consumer as `props.context`\");\n                        }\n                        ResultContext = propsContext;\n                    }\n                }\n                return ResultContext;\n            }, [\n                propsContext,\n                Context\n            ]);\n            const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ContextToUse);\n            const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n            const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n            if ( true && !didStoreComeFromProps && !didStoreComeFromContext) {\n                throw new Error(`Could not find \"store\" in the context of \"${displayName}\". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`);\n            }\n            const store = didStoreComeFromProps ? props.store : contextValue.store;\n            const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n            const childPropsSelector = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\n            }, [\n                store\n            ]);\n            const [subscription, notifyNestedSubs] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;\n                const subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);\n                const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);\n                return [\n                    subscription2,\n                    notifyNestedSubs2\n                ];\n            }, [\n                store,\n                didStoreComeFromProps,\n                contextValue\n            ]);\n            const overriddenContextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                if (didStoreComeFromProps) {\n                    return contextValue;\n                }\n                return {\n                    ...contextValue,\n                    subscription\n                };\n            }, [\n                didStoreComeFromProps,\n                contextValue,\n                subscription\n            ]);\n            const lastChildProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n            const lastWrapperProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(wrapperProps);\n            const childPropsFromStoreUpdate = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n            const renderIsScheduled = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n            const isMounted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n            const latestSubscriptionCallbackError = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n            useIsomorphicLayoutEffect(()=>{\n                isMounted.current = true;\n                return ()=>{\n                    isMounted.current = false;\n                };\n            }, []);\n            const actualChildPropsSelector = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                const selector = ()=>{\n                    if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n                        return childPropsFromStoreUpdate.current;\n                    }\n                    return childPropsSelector(store.getState(), wrapperProps);\n                };\n                return selector;\n            }, [\n                store,\n                wrapperProps\n            ]);\n            const subscribeForReact = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                const subscribe = (reactListener)=>{\n                    if (!subscription) {\n                        return ()=>{};\n                    }\n                    return subscribeUpdates(shouldHandleStateChanges, store, subscription, // @ts-ignore\n                    childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);\n                };\n                return subscribe;\n            }, [\n                subscription\n            ]);\n            useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [\n                lastWrapperProps,\n                lastChildProps,\n                renderIsScheduled,\n                wrapperProps,\n                childPropsFromStoreUpdate,\n                notifyNestedSubs\n            ]);\n            let actualChildProps;\n            try {\n                actualChildProps = react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore(// TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n                subscribeForReact, // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n                // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n                actualChildPropsSelector, getServerState ? ()=>childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector);\n            } catch (err) {\n                if (latestSubscriptionCallbackError.current) {\n                    ;\n                    err.message += `\nThe error may be correlated with this previous error:\n${latestSubscriptionCallbackError.current.stack}\n\n`;\n                }\n                throw err;\n            }\n            useIsomorphicLayoutEffect(()=>{\n                latestSubscriptionCallbackError.current = void 0;\n                childPropsFromStoreUpdate.current = void 0;\n                lastChildProps.current = actualChildProps;\n            });\n            const renderedWrappedComponent = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                return(// @ts-ignore\n                /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(WrappedComponent, {\n                    ...actualChildProps,\n                    ref: reactReduxForwardedRef\n                }));\n            }, [\n                reactReduxForwardedRef,\n                WrappedComponent,\n                actualChildProps\n            ]);\n            const renderedChild = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                if (shouldHandleStateChanges) {\n                    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextToUse.Provider, {\n                        value: overriddenContextValue\n                    }, renderedWrappedComponent);\n                }\n                return renderedWrappedComponent;\n            }, [\n                ContextToUse,\n                renderedWrappedComponent,\n                overriddenContextValue\n            ]);\n            return renderedChild;\n        }\n        const _Connect = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(ConnectFunction);\n        const Connect = _Connect;\n        Connect.WrappedComponent = WrappedComponent;\n        Connect.displayName = ConnectFunction.displayName = displayName;\n        if (forwardRef) {\n            const _forwarded = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function forwardConnectRef(props, ref) {\n                return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Connect, {\n                    ...props,\n                    reactReduxForwardedRef: ref\n                });\n            });\n            const forwarded = _forwarded;\n            forwarded.displayName = displayName;\n            forwarded.WrappedComponent = WrappedComponent;\n            return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);\n        }\n        return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);\n    };\n    return wrapWithConnect;\n}\nvar connect_default = connect;\n// src/components/Provider.tsx\nfunction Provider(providerProps) {\n    const { children, context, serverState, store } = providerProps;\n    const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        const subscription = createSubscription(store);\n        const baseContextValue = {\n            store,\n            subscription,\n            getServerState: serverState ? ()=>serverState : void 0\n        };\n        if (false) {} else {\n            const { identityFunctionCheck = \"once\", stabilityCheck = \"once\" } = providerProps;\n            return /* @__PURE__ */ Object.assign(baseContextValue, {\n                stabilityCheck,\n                identityFunctionCheck\n            });\n        }\n    }, [\n        store,\n        serverState\n    ]);\n    const previousState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>store.getState(), [\n        store\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        const { subscription } = contextValue;\n        subscription.onStateChange = subscription.notifyNestedSubs;\n        subscription.trySubscribe();\n        if (previousState !== store.getState()) {\n            subscription.notifyNestedSubs();\n        }\n        return ()=>{\n            subscription.tryUnsubscribe();\n            subscription.onStateChange = void 0;\n        };\n    }, [\n        contextValue,\n        previousState\n    ]);\n    const Context = context || ReactReduxContext;\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Context.Provider, {\n        value: contextValue\n    }, children);\n}\nvar Provider_default = Provider;\n// src/hooks/useReduxContext.ts\nfunction createReduxContextHook(context = ReactReduxContext) {\n    return function useReduxContext2() {\n        const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n        if ( true && !contextValue) {\n            throw new Error(\"could not find react-redux context value; please ensure the component is wrapped in a <Provider>\");\n        }\n        return contextValue;\n    };\n}\nvar useReduxContext = /* @__PURE__ */ createReduxContextHook();\n// src/hooks/useStore.ts\nfunction createStoreHook(context = ReactReduxContext) {\n    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : // @ts-ignore\n    createReduxContextHook(context);\n    const useStore2 = ()=>{\n        const { store } = useReduxContext2();\n        return store;\n    };\n    Object.assign(useStore2, {\n        withTypes: ()=>useStore2\n    });\n    return useStore2;\n}\nvar useStore = /* @__PURE__ */ createStoreHook();\n// src/hooks/useDispatch.ts\nfunction createDispatchHook(context = ReactReduxContext) {\n    const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);\n    const useDispatch2 = ()=>{\n        const store = useStore2();\n        return store.dispatch;\n    };\n    Object.assign(useDispatch2, {\n        withTypes: ()=>useDispatch2\n    });\n    return useDispatch2;\n}\nvar useDispatch = /* @__PURE__ */ createDispatchHook();\n// src/hooks/useSelector.ts\n\nvar refEquality = (a, b)=>a === b;\nfunction createSelectorHook(context = ReactReduxContext) {\n    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);\n    const useSelector2 = (selector, equalityFnOrOptions = {})=>{\n        const { equalityFn = refEquality } = typeof equalityFnOrOptions === \"function\" ? {\n            equalityFn: equalityFnOrOptions\n        } : equalityFnOrOptions;\n        if (true) {\n            if (!selector) {\n                throw new Error(`You must pass a selector to useSelector`);\n            }\n            if (typeof selector !== \"function\") {\n                throw new Error(`You must pass a function as a selector to useSelector`);\n            }\n            if (typeof equalityFn !== \"function\") {\n                throw new Error(`You must pass a function as an equality function to useSelector`);\n            }\n        }\n        const reduxContext = useReduxContext2();\n        const { store, subscription, getServerState } = reduxContext;\n        const firstRun = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n            [selector.name] (state) {\n                const selected = selector(state);\n                if (true) {\n                    const { devModeChecks = {} } = typeof equalityFnOrOptions === \"function\" ? {} : equalityFnOrOptions;\n                    const { identityFunctionCheck, stabilityCheck } = reduxContext;\n                    const { identityFunctionCheck: finalIdentityFunctionCheck, stabilityCheck: finalStabilityCheck } = {\n                        stabilityCheck,\n                        identityFunctionCheck,\n                        ...devModeChecks\n                    };\n                    if (finalStabilityCheck === \"always\" || finalStabilityCheck === \"once\" && firstRun.current) {\n                        const toCompare = selector(state);\n                        if (!equalityFn(selected, toCompare)) {\n                            let stack = void 0;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                ;\n                                ({ stack } = e);\n                            }\n                            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\", {\n                                state,\n                                selected,\n                                selected2: toCompare,\n                                stack\n                            });\n                        }\n                    }\n                    if (finalIdentityFunctionCheck === \"always\" || finalIdentityFunctionCheck === \"once\" && firstRun.current) {\n                        if (selected === state) {\n                            let stack = void 0;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                ;\n                                ({ stack } = e);\n                            }\n                            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned the root state when called. This can lead to unnecessary rerenders.\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.\", {\n                                stack\n                            });\n                        }\n                    }\n                    if (firstRun.current) firstRun.current = false;\n                }\n                return selected;\n            }\n        }[selector.name], [\n            selector\n        ]);\n        const selectedState = (0,use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);\n        react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue(selectedState);\n        return selectedState;\n    };\n    Object.assign(useSelector2, {\n        withTypes: ()=>useSelector2\n    });\n    return useSelector2;\n}\nvar useSelector = /* @__PURE__ */ createSelectorHook();\n// src/exports.ts\nvar batch = defaultNoopBatch;\n //# sourceMappingURL=react-redux.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2Rpc3QvcmVhY3QtcmVkdXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxxQkFBcUI7QUFDVTtBQUUvQix3QkFBd0I7QUFDeEIsSUFBSUMsY0FBYyxhQUFhLEdBQUdELDBDQUFhLENBQUNHLFVBQVUsQ0FBQztBQUMzRCxJQUFJQyxxQkFBcUIsYUFBYSxHQUFHQyxPQUFPQyxHQUFHLENBQ2pETCxjQUFjLCtCQUErQjtBQUUvQyxJQUFJTSxvQkFBb0IsYUFBYSxHQUFHRixPQUFPQyxHQUFHLENBQUM7QUFDbkQsSUFBSUUsc0JBQXNCLGFBQWEsR0FBR0gsT0FBT0MsR0FBRyxDQUFDO0FBQ3JELElBQUlHLHlCQUF5QixhQUFhLEdBQUdKLE9BQU9DLEdBQUcsQ0FBQztBQUN4RCxJQUFJSSxzQkFBc0IsYUFBYSxHQUFHTCxPQUFPQyxHQUFHLENBQUM7QUFDckQsSUFBSUssc0JBQXNCLGFBQWEsR0FBR04sT0FBT0MsR0FBRyxDQUFDO0FBQ3JELElBQUlNLHFCQUFxQixhQUFhLEdBQUdQLE9BQU9DLEdBQUcsQ0FBQztBQUNwRCxJQUFJTyx5QkFBeUIsYUFBYSxHQUFHUixPQUFPQyxHQUFHLENBQUM7QUFDeEQsSUFBSVEsc0JBQXNCLGFBQWEsR0FBR1QsT0FBT0MsR0FBRyxDQUFDO0FBQ3JELElBQUlTLDJCQUEyQixhQUFhLEdBQUdWLE9BQU9DLEdBQUcsQ0FDdkQ7QUFFRixJQUFJVSxrQkFBa0IsYUFBYSxHQUFHWCxPQUFPQyxHQUFHLENBQUM7QUFDakQsSUFBSVcsa0JBQWtCLGFBQWEsR0FBR1osT0FBT0MsR0FBRyxDQUFDO0FBQ2pELElBQUlZLHVCQUF1QixhQUFhLEdBQUdiLE9BQU9DLEdBQUcsQ0FBQztBQUN0RCxJQUFJYSx5QkFBeUIsYUFBYSxHQUFHZCxPQUFPQyxHQUFHLENBQ3JEO0FBRUYsSUFBSWMsYUFBYVA7QUFDakIsSUFBSVEsT0FBT0w7QUFDWCxTQUFTTSxtQkFBbUJD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QUNqQixJQUFJO2dDQUNGLE1BQU0sSUFBSW5ROzRCQUNaLEVBQUUsT0FBT0MsR0FBRzs7Z0NBRVQsR0FBRWtRLEtBQUssRUFBRSxHQUFHbFEsQ0FBQUE7NEJBQ2Y7NEJBQ0FILFFBQVFtVCxJQUFJLENBQ1YsY0FBZTlTLENBQUFBLFNBQVMwRSxJQUFJLElBQUksU0FBUSxJQUFLLDZOQUM3QztnQ0FBRXNMOzRCQUFNO3dCQUVaO29CQUNGO29CQUNBLElBQUlzQyxTQUFTekYsT0FBTyxFQUFFeUYsU0FBU3pGLE9BQU8sR0FBRztnQkFDM0M7Z0JBQ0EsT0FBTzRGO1lBQ1Q7UUFDRixDQUFDLENBQUN6UyxTQUFTMEUsSUFBSSxDQUFDLEVBQ2hCO1lBQUMxRTtTQUFTO1FBRVosTUFBTWdULGdCQUFnQmpCLDBHQUFnQ0EsQ0FDcEQ1SyxhQUFhUCxZQUFZLEVBQ3pCSixNQUFNK0csUUFBUSxFQUNkNkIsa0JBQWtCNUksTUFBTStHLFFBQVEsRUFDaENnRixpQkFDQUg7UUFFRnpVLGdEQUFtQixDQUFDcVY7UUFDcEIsT0FBT0E7SUFDVDtJQUNBOVMsT0FBT2dSLE1BQU0sQ0FBQ2dCLGNBQWM7UUFDMUJSLFdBQVcsSUFBTVE7SUFDbkI7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsSUFBSWdCLGNBQWMsYUFBYSxHQUFHakI7QUFFbEMsaUJBQWlCO0FBQ2pCLElBQUlrQixRQUFRN047QUFhVixDQUNGLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbW1lcmNpYWwtcmUtY2FsYy1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZGlzdC9yZWFjdC1yZWR1eC5tanM/ZDQ5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMvcmVhY3QudHNcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdXRpbHMvcmVhY3QtaXMudHNcbnZhciBJU19SRUFDVF8xOSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC52ZXJzaW9uLnN0YXJ0c1dpdGgoXCIxOVwiKTtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcbiAgSVNfUkVBQ1RfMTkgPyBcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIgOiBcInJlYWN0LmVsZW1lbnRcIlxuKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcbiAgXCJyZWFjdC5zdXNwZW5zZV9saXN0XCJcbik7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpO1xudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcbiAgXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCJcbik7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSBcIm9iamVjdFwiICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHZvaWQgMCkgPyB0cnVlIDogZmFsc2U7XG59XG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHsgJCR0eXBlb2YgfSA9IG9iamVjdDtcbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgc3dpdGNoIChvYmplY3QgPSBvYmplY3QudHlwZSwgb2JqZWN0KSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3dpdGNoIChvYmplY3QgPSBvYmplY3QgJiYgb2JqZWN0LiQkdHlwZW9mLCBvYmplY3QpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiBJU19SRUFDVF8xOSA/IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05TVU1FUl9UWVBFIDogdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5cbi8vIHNyYy91dGlscy93YXJuaW5nLnRzXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIHRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxuLy8gc3JjL2Nvbm5lY3QvdmVyaWZ5U3Vic2VsZWN0b3JzLnRzXG5mdW5jdGlvbiB2ZXJpZnkoc2VsZWN0b3IsIG1ldGhvZE5hbWUpIHtcbiAgaWYgKCFzZWxlY3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB2YWx1ZSBmb3IgJHttZXRob2ROYW1lfSBpbiBjb25uZWN0LmApO1xuICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09IFwibWFwU3RhdGVUb1Byb3BzXCIgfHwgbWV0aG9kTmFtZSA9PT0gXCJtYXBEaXNwYXRjaFRvUHJvcHNcIikge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGVjdG9yLCBcImRlcGVuZHNPbk93blByb3BzXCIpKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBgVGhlIHNlbGVjdG9yIGZvciAke21ldGhvZE5hbWV9IG9mIGNvbm5lY3QgZGlkIG5vdCBzcGVjaWZ5IGEgdmFsdWUgZm9yIGRlcGVuZHNPbk93blByb3BzLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpIHtcbiAgdmVyaWZ5KG1hcFN0YXRlVG9Qcm9wcywgXCJtYXBTdGF0ZVRvUHJvcHNcIik7XG4gIHZlcmlmeShtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpO1xuICB2ZXJpZnkobWVyZ2VQcm9wcywgXCJtZXJnZVByb3BzXCIpO1xufVxuXG4vLyBzcmMvY29ubmVjdC9zZWxlY3RvckZhY3RvcnkudHNcbmZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCwge1xuICBhcmVTdGF0ZXNFcXVhbCxcbiAgYXJlT3duUHJvcHNFcXVhbCxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsXG59KSB7XG4gIGxldCBoYXNSdW5BdExlYXN0T25jZSA9IGZhbHNlO1xuICBsZXQgc3RhdGU7XG4gIGxldCBvd25Qcm9wcztcbiAgbGV0IHN0YXRlUHJvcHM7XG4gIGxldCBkaXNwYXRjaFByb3BzO1xuICBsZXQgbWVyZ2VkUHJvcHM7XG4gIGZ1bmN0aW9uIGhhbmRsZUZpcnN0Q2FsbChmaXJzdFN0YXRlLCBmaXJzdE93blByb3BzKSB7XG4gICAgc3RhdGUgPSBmaXJzdFN0YXRlO1xuICAgIG93blByb3BzID0gZmlyc3RPd25Qcm9wcztcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgaGFzUnVuQXRMZWFzdE9uY2UgPSB0cnVlO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCkge1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBpZiAobWFwRGlzcGF0Y2hUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKVxuICAgICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzKCkge1xuICAgIGlmIChtYXBTdGF0ZVRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpXG4gICAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOZXdTdGF0ZSgpIHtcbiAgICBjb25zdCBuZXh0U3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGNvbnN0IHN0YXRlUHJvcHNDaGFuZ2VkID0gIWFyZVN0YXRlUHJvcHNFcXVhbChuZXh0U3RhdGVQcm9wcywgc3RhdGVQcm9wcyk7XG4gICAgc3RhdGVQcm9wcyA9IG5leHRTdGF0ZVByb3BzO1xuICAgIGlmIChzdGF0ZVByb3BzQ2hhbmdlZClcbiAgICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIGNvbnN0IHByb3BzQ2hhbmdlZCA9ICFhcmVPd25Qcm9wc0VxdWFsKG5leHRPd25Qcm9wcywgb3duUHJvcHMpO1xuICAgIGNvbnN0IHN0YXRlQ2hhbmdlZCA9ICFhcmVTdGF0ZXNFcXVhbChcbiAgICAgIG5leHRTdGF0ZSxcbiAgICAgIHN0YXRlLFxuICAgICAgbmV4dE93blByb3BzLFxuICAgICAgb3duUHJvcHNcbiAgICApO1xuICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuICAgIG93blByb3BzID0gbmV4dE93blByb3BzO1xuICAgIGlmIChwcm9wc0NoYW5nZWQgJiYgc3RhdGVDaGFuZ2VkKSByZXR1cm4gaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSgpO1xuICAgIGlmIChwcm9wc0NoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wcygpO1xuICAgIGlmIChzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdTdGF0ZSgpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvcihuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIHJldHVybiBoYXNSdW5BdExlYXN0T25jZSA/IGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykgOiBoYW5kbGVGaXJzdENhbGwobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpO1xuICB9O1xufVxuZnVuY3Rpb24gZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShkaXNwYXRjaCwge1xuICBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICBpbml0TWVyZ2VQcm9wcyxcbiAgLi4ub3B0aW9uc1xufSkge1xuICBjb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSBpbml0TWFwU3RhdGVUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzID0gaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGNvbnN0IG1lcmdlUHJvcHMgPSBpbml0TWVyZ2VQcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpO1xuICB9XG4gIHJldHVybiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIG9wdGlvbnMpO1xufVxuXG4vLyBzcmMvdXRpbHMvYmluZEFjdGlvbkNyZWF0b3JzLnRzXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGNvbnN0IGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gYWN0aW9uQ3JlYXRvcnMpIHtcbiAgICBjb25zdCBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNba2V5XTtcbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gKC4uLmFyZ3MpID0+IGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IoLi4uYXJncykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn1cblxuLy8gc3JjL3V0aWxzL2lzUGxhaW5PYmplY3QudHNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHJldHVybiB0cnVlO1xuICBsZXQgYmFzZVByb3RvID0gcHJvdG87XG4gIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKSAhPT0gbnVsbCkge1xuICAgIGJhc2VQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlUHJvdG8pO1xuICB9XG4gIHJldHVybiBwcm90byA9PT0gYmFzZVByb3RvO1xufVxuXG4vLyBzcmMvdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QudHNcbmZ1bmN0aW9uIHZlcmlmeVBsYWluT2JqZWN0KHZhbHVlLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGAke21ldGhvZE5hbWV9KCkgaW4gJHtkaXNwbGF5TmFtZX0gbXVzdCByZXR1cm4gYSBwbGFpbiBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQgJHt2YWx1ZX0uYFxuICAgICk7XG4gIH1cbn1cblxuLy8gc3JjL2Nvbm5lY3Qvd3JhcE1hcFRvUHJvcHMudHNcbmZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoZ2V0Q29uc3RhbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRDb25zdGFudFNlbGVjdG9yKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgY29uc3RhbnQgPSBnZXRDb25zdGFudChkaXNwYXRjaCk7XG4gICAgZnVuY3Rpb24gY29uc3RhbnRTZWxlY3RvcigpIHtcbiAgICAgIHJldHVybiBjb25zdGFudDtcbiAgICB9XG4gICAgY29uc3RhbnRTZWxlY3Rvci5kZXBlbmRzT25Pd25Qcm9wcyA9IGZhbHNlO1xuICAgIHJldHVybiBjb25zdGFudFNlbGVjdG9yO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcykge1xuICByZXR1cm4gbWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcyA/IEJvb2xlYW4obWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgOiBtYXBUb1Byb3BzLmxlbmd0aCAhPT0gMTtcbn1cbmZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBUb1Byb3BzLCBtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0UHJveHlTZWxlY3RvcihkaXNwYXRjaCwgeyBkaXNwbGF5TmFtZSB9KSB7XG4gICAgY29uc3QgcHJveHkgPSBmdW5jdGlvbiBtYXBUb1Byb3BzUHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcmV0dXJuIHByb3h5LmRlcGVuZHNPbk93blByb3BzID8gcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSA6IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCB2b2lkIDApO1xuICAgIH07XG4gICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSB0cnVlO1xuICAgIHByb3h5Lm1hcFRvUHJvcHMgPSBmdW5jdGlvbiBkZXRlY3RGYWN0b3J5QW5kVmVyaWZ5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHByb3h5Lm1hcFRvUHJvcHMgPSBtYXBUb1Byb3BzO1xuICAgICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSBnZXREZXBlbmRzT25Pd25Qcm9wcyhtYXBUb1Byb3BzKTtcbiAgICAgIGxldCBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHByb3h5Lm1hcFRvUHJvcHMgPSBwcm9wcztcbiAgICAgICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSBnZXREZXBlbmRzT25Pd25Qcm9wcyhwcm9wcyk7XG4gICAgICAgIHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKVxuICAgICAgICB2ZXJpZnlQbGFpbk9iamVjdChwcm9wcywgZGlzcGxheU5hbWUsIG1ldGhvZE5hbWUpO1xuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH07XG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xufVxuXG4vLyBzcmMvY29ubmVjdC9pbnZhbGlkQXJnRmFjdG9yeS50c1xuZnVuY3Rpb24gY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkoYXJnLCBuYW1lKSB7XG4gIHJldHVybiAoZGlzcGF0Y2gsIG9wdGlvbnMpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGFyZ30gZm9yICR7bmFtZX0gYXJndW1lbnQgd2hlbiBjb25uZWN0aW5nIGNvbXBvbmVudCAke29wdGlvbnMud3JhcHBlZENvbXBvbmVudE5hbWV9LmBcbiAgICApO1xuICB9O1xufVxuXG4vLyBzcmMvY29ubmVjdC9tYXBEaXNwYXRjaFRvUHJvcHMudHNcbmZ1bmN0aW9uIG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gIHJldHVybiBtYXBEaXNwYXRjaFRvUHJvcHMgJiYgdHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gXCJvYmplY3RcIiA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoXG4gICAgKGRpc3BhdGNoKSA9PiAoXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBiaW5kQWN0aW9uQ3JlYXRvcnMobWFwRGlzcGF0Y2hUb1Byb3BzLCBkaXNwYXRjaClcbiAgICApXG4gICkgOiAhbWFwRGlzcGF0Y2hUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudCgoZGlzcGF0Y2gpID0+ICh7XG4gICAgZGlzcGF0Y2hcbiAgfSkpIDogdHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwRGlzcGF0Y2hUb1Byb3BzLCBcIm1hcERpc3BhdGNoVG9Qcm9wc1wiKVxuICApIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzLCBcIm1hcERpc3BhdGNoVG9Qcm9wc1wiKTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvbWFwU3RhdGVUb1Byb3BzLnRzXG5mdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcykge1xuICByZXR1cm4gIW1hcFN0YXRlVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoKCkgPT4gKHt9KSkgOiB0eXBlb2YgbWFwU3RhdGVUb1Byb3BzID09PSBcImZ1bmN0aW9uXCIgPyAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBTdGF0ZVRvUHJvcHMsIFwibWFwU3RhdGVUb1Byb3BzXCIpXG4gICkgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIFwibWFwU3RhdGVUb1Byb3BzXCIpO1xufVxuXG4vLyBzcmMvY29ubmVjdC9tZXJnZVByb3BzLnRzXG5mdW5jdGlvbiBkZWZhdWx0TWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICByZXR1cm4geyAuLi5vd25Qcm9wcywgLi4uc3RhdGVQcm9wcywgLi4uZGlzcGF0Y2hQcm9wcyB9O1xufVxuZnVuY3Rpb24gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRNZXJnZVByb3BzUHJveHkoZGlzcGF0Y2gsIHsgZGlzcGxheU5hbWUsIGFyZU1lcmdlZFByb3BzRXF1YWwgfSkge1xuICAgIGxldCBoYXNSdW5PbmNlID0gZmFsc2U7XG4gICAgbGV0IG1lcmdlZFByb3BzO1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZVByb3BzUHJveHkoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgICAgIGNvbnN0IG5leHRNZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgICAgaWYgKGhhc1J1bk9uY2UpIHtcbiAgICAgICAgaWYgKCFhcmVNZXJnZWRQcm9wc0VxdWFsKG5leHRNZXJnZWRQcm9wcywgbWVyZ2VkUHJvcHMpKVxuICAgICAgICAgIG1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzUnVuT25jZSA9IHRydWU7XG4gICAgICAgIG1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKVxuICAgICAgICAgIHZlcmlmeVBsYWluT2JqZWN0KG1lcmdlZFByb3BzLCBkaXNwbGF5TmFtZSwgXCJtZXJnZVByb3BzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZVByb3BzRmFjdG9yeShtZXJnZVByb3BzKSB7XG4gIHJldHVybiAhbWVyZ2VQcm9wcyA/ICgpID0+IGRlZmF1bHRNZXJnZVByb3BzIDogdHlwZW9mIG1lcmdlUHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSA6IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KG1lcmdlUHJvcHMsIFwibWVyZ2VQcm9wc1wiKTtcbn1cblxuLy8gc3JjL3V0aWxzL2JhdGNoLnRzXG5mdW5jdGlvbiBkZWZhdWx0Tm9vcEJhdGNoKGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKCk7XG59XG5cbi8vIHNyYy91dGlscy9TdWJzY3JpcHRpb24udHNcbmZ1bmN0aW9uIGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpIHtcbiAgbGV0IGZpcnN0ID0gbnVsbDtcbiAgbGV0IGxhc3QgPSBudWxsO1xuICByZXR1cm4ge1xuICAgIGNsZWFyKCkge1xuICAgICAgZmlyc3QgPSBudWxsO1xuICAgICAgbGFzdCA9IG51bGw7XG4gICAgfSxcbiAgICBub3RpZnkoKSB7XG4gICAgICBkZWZhdWx0Tm9vcEJhdGNoKCgpID0+IHtcbiAgICAgICAgbGV0IGxpc3RlbmVyID0gZmlyc3Q7XG4gICAgICAgIHdoaWxlIChsaXN0ZW5lcikge1xuICAgICAgICAgIGxpc3RlbmVyLmNhbGxiYWNrKCk7XG4gICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFtdO1xuICAgICAgbGV0IGxpc3RlbmVyID0gZmlyc3Q7XG4gICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlzdGVuZXJzO1xuICAgIH0sXG4gICAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgICBsZXQgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gbGFzdCA9IHtcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgIHByZXY6IGxhc3RcbiAgICAgIH07XG4gICAgICBpZiAobGlzdGVuZXIucHJldikge1xuICAgICAgICBsaXN0ZW5lci5wcmV2Lm5leHQgPSBsaXN0ZW5lcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0ID0gbGlzdGVuZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICghaXNTdWJzY3JpYmVkIHx8IGZpcnN0ID09PSBudWxsKSByZXR1cm47XG4gICAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICBpZiAobGlzdGVuZXIubmV4dCkge1xuICAgICAgICAgIGxpc3RlbmVyLm5leHQucHJldiA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdCA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyLnByZXYpIHtcbiAgICAgICAgICBsaXN0ZW5lci5wcmV2Lm5leHQgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpcnN0ID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG52YXIgbnVsbExpc3RlbmVycyA9IHtcbiAgbm90aWZ5KCkge1xuICB9LFxuICBnZXQ6ICgpID0+IFtdXG59O1xuZnVuY3Rpb24gY3JlYXRlU3Vic2NyaXB0aW9uKHN0b3JlLCBwYXJlbnRTdWIpIHtcbiAgbGV0IHVuc3Vic2NyaWJlO1xuICBsZXQgbGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgbGV0IHN1YnNjcmlwdGlvbnNBbW91bnQgPSAwO1xuICBsZXQgc2VsZlN1YnNjcmliZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gYWRkTmVzdGVkU3ViKGxpc3RlbmVyKSB7XG4gICAgdHJ5U3Vic2NyaWJlKCk7XG4gICAgY29uc3QgY2xlYW51cExpc3RlbmVyID0gbGlzdGVuZXJzLnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFyZW1vdmVkKSB7XG4gICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwTGlzdGVuZXIoKTtcbiAgICAgICAgdHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeU5lc3RlZFN1YnMoKSB7XG4gICAgbGlzdGVuZXJzLm5vdGlmeSgpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUNoYW5nZVdyYXBwZXIoKSB7XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlKSB7XG4gICAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgcmV0dXJuIHNlbGZTdWJzY3JpYmVkO1xuICB9XG4gIGZ1bmN0aW9uIHRyeVN1YnNjcmliZSgpIHtcbiAgICBzdWJzY3JpcHRpb25zQW1vdW50Kys7XG4gICAgaWYgKCF1bnN1YnNjcmliZSkge1xuICAgICAgdW5zdWJzY3JpYmUgPSBwYXJlbnRTdWIgPyBwYXJlbnRTdWIuYWRkTmVzdGVkU3ViKGhhbmRsZUNoYW5nZVdyYXBwZXIpIDogc3RvcmUuc3Vic2NyaWJlKGhhbmRsZUNoYW5nZVdyYXBwZXIpO1xuICAgICAgbGlzdGVuZXJzID0gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlKCkge1xuICAgIHN1YnNjcmlwdGlvbnNBbW91bnQtLTtcbiAgICBpZiAodW5zdWJzY3JpYmUgJiYgc3Vic2NyaXB0aW9uc0Ftb3VudCA9PT0gMCkge1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIHVuc3Vic2NyaWJlID0gdm9pZCAwO1xuICAgICAgbGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICBsaXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cnlTdWJzY3JpYmVTZWxmKCkge1xuICAgIGlmICghc2VsZlN1YnNjcmliZWQpIHtcbiAgICAgIHNlbGZTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgIHRyeVN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZVNlbGYoKSB7XG4gICAgaWYgKHNlbGZTdWJzY3JpYmVkKSB7XG4gICAgICBzZWxmU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgdHJ5VW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3Vic2NyaXB0aW9uID0ge1xuICAgIGFkZE5lc3RlZFN1YixcbiAgICBub3RpZnlOZXN0ZWRTdWJzLFxuICAgIGhhbmRsZUNoYW5nZVdyYXBwZXIsXG4gICAgaXNTdWJzY3JpYmVkLFxuICAgIHRyeVN1YnNjcmliZTogdHJ5U3Vic2NyaWJlU2VsZixcbiAgICB0cnlVbnN1YnNjcmliZTogdHJ5VW5zdWJzY3JpYmVTZWxmLFxuICAgIGdldExpc3RlbmVyczogKCkgPT4gbGlzdGVuZXJzXG4gIH07XG4gIHJldHVybiBzdWJzY3JpcHRpb247XG59XG5cbi8vIHNyYy91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LnRzXG52YXIgY2FuVXNlRE9NID0gKCkgPT4gISEodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIik7XG52YXIgaXNET00gPSAvKiBAX19QVVJFX18gKi8gY2FuVXNlRE9NKCk7XG52YXIgaXNSdW5uaW5nSW5SZWFjdE5hdGl2ZSA9ICgpID0+IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIjtcbnZhciBpc1JlYWN0TmF0aXZlID0gLyogQF9fUFVSRV9fICovIGlzUnVubmluZ0luUmVhY3ROYXRpdmUoKTtcbnZhciBnZXRVc2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gKCkgPT4gaXNET00gfHwgaXNSZWFjdE5hdGl2ZSA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gLyogQF9fUFVSRV9fICovIGdldFVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKTtcblxuLy8gc3JjL3V0aWxzL3NoYWxsb3dFcXVhbC50c1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSkgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gXCJvYmplY3RcIiB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSBcIm9iamVjdFwiIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy91dGlscy9ob2lzdFN0YXRpY3MudHNcbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgY29udGV4dFR5cGU6IHRydWUsXG4gIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogdHJ1ZSxcbiAgbWl4aW5zOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgbmFtZTogdHJ1ZSxcbiAgbGVuZ3RoOiB0cnVlLFxuICBwcm90b3R5cGU6IHRydWUsXG4gIGNhbGxlcjogdHJ1ZSxcbiAgY2FsbGVlOiB0cnVlLFxuICBhcmd1bWVudHM6IHRydWUsXG4gIGFyaXR5OiB0cnVlXG59O1xudmFyIEZPUldBUkRfUkVGX1NUQVRJQ1MgPSB7XG4gICQkdHlwZW9mOiB0cnVlLFxuICByZW5kZXI6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZVxufTtcbnZhciBNRU1PX1NUQVRJQ1MgPSB7XG4gICQkdHlwZW9mOiB0cnVlLFxuICBjb21wYXJlOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgVFlQRV9TVEFUSUNTID0ge1xuICBbRm9yd2FyZFJlZl06IEZPUldBUkRfUkVGX1NUQVRJQ1MsXG4gIFtNZW1vXTogTUVNT19TVEFUSUNTXG59O1xuZnVuY3Rpb24gZ2V0U3RhdGljcyhjb21wb25lbnQpIHtcbiAgaWYgKGlzTWVtbyhjb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIE1FTU9fU1RBVElDUztcbiAgfVxuICByZXR1cm4gVFlQRV9TVEFUSUNTW2NvbXBvbmVudFtcIiQkdHlwZW9mXCJdXSB8fCBSRUFDVF9TVEFUSUNTO1xufVxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbmZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50KSB7XG4gIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgY29uc3QgaW5oZXJpdGVkQ29tcG9uZW50ID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlQ29tcG9uZW50KTtcbiAgICAgIGlmIChpbmhlcml0ZWRDb21wb25lbnQgJiYgaW5oZXJpdGVkQ29tcG9uZW50ICE9PSBvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcbiAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRTdGF0aWNzID0gZ2V0U3RhdGljcyh0YXJnZXRDb21wb25lbnQpO1xuICAgIGNvbnN0IHNvdXJjZVN0YXRpY3MgPSBnZXRTdGF0aWNzKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKCFLTk9XTl9TVEFUSUNTW2tleV0gJiYgIShzb3VyY2VTdGF0aWNzICYmIHNvdXJjZVN0YXRpY3Nba2V5XSkgJiYgISh0YXJnZXRTdGF0aWNzICYmIHRhcmdldFN0YXRpY3Nba2V5XSkpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvQ29udGV4dC50c1xudmFyIENvbnRleHRLZXkgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihgcmVhY3QtcmVkdXgtY29udGV4dGApO1xudmFyIGdUID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogKFxuICAvKiBmYWxsIGJhY2sgdG8gYSBwZXItbW9kdWxlIHNjb3BlIChwcmUtOC4xIGJlaGF2aW91cikgaWYgYGdsb2JhbFRoaXNgIGlzIG5vdCBhdmFpbGFibGUgKi9cbiAge31cbik7XG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICBpZiAoIVJlYWN0LmNyZWF0ZUNvbnRleHQpIHJldHVybiB7fTtcbiAgY29uc3QgY29udGV4dE1hcCA9IGdUW0NvbnRleHRLZXldID8/PSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgcmVhbENvbnRleHQgPSBjb250ZXh0TWFwLmdldChSZWFjdC5jcmVhdGVDb250ZXh0KTtcbiAgaWYgKCFyZWFsQ29udGV4dCkge1xuICAgIHJlYWxDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChcbiAgICAgIG51bGxcbiAgICApO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJlYWxDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSZWFjdFJlZHV4XCI7XG4gICAgfVxuICAgIGNvbnRleHRNYXAuc2V0KFJlYWN0LmNyZWF0ZUNvbnRleHQsIHJlYWxDb250ZXh0KTtcbiAgfVxuICByZXR1cm4gcmVhbENvbnRleHQ7XG59XG52YXIgUmVhY3RSZWR1eENvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gZ2V0Q29udGV4dCgpO1xuXG4vLyBzcmMvY29tcG9uZW50cy9jb25uZWN0LnRzeFxudmFyIE5PX1NVQlNDUklQVElPTl9BUlJBWSA9IFtudWxsLCBudWxsXTtcbnZhciBzdHJpbmdpZnlDb21wb25lbnQgPSAoQ29tcCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShDb21wKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZyhDb21wKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyhlZmZlY3RGdW5jLCBlZmZlY3RBcmdzLCBkZXBlbmRlbmNpZXMpIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiBlZmZlY3RGdW5jKC4uLmVmZmVjdEFyZ3MpLCBkZXBlbmRlbmNpZXMpO1xufVxuZnVuY3Rpb24gY2FwdHVyZVdyYXBwZXJQcm9wcyhsYXN0V3JhcHBlclByb3BzLCBsYXN0Q2hpbGRQcm9wcywgcmVuZGVySXNTY2hlZHVsZWQsIHdyYXBwZXJQcm9wcywgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSwgbm90aWZ5TmVzdGVkU3Vicykge1xuICBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQgPSB3cmFwcGVyUHJvcHM7XG4gIHJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgaWYgKGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCkge1xuICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IG51bGw7XG4gICAgbm90aWZ5TmVzdGVkU3VicygpO1xuICB9XG59XG5mdW5jdGlvbiBzdWJzY3JpYmVVcGRhdGVzKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcywgc3RvcmUsIHN1YnNjcmlwdGlvbiwgY2hpbGRQcm9wc1NlbGVjdG9yLCBsYXN0V3JhcHBlclByb3BzLCBsYXN0Q2hpbGRQcm9wcywgcmVuZGVySXNTY2hlZHVsZWQsIGlzTW91bnRlZCwgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSwgbm90aWZ5TmVzdGVkU3VicywgYWRkaXRpb25hbFN1YnNjcmliZUxpc3RlbmVyKSB7XG4gIGlmICghc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSByZXR1cm4gKCkgPT4ge1xuICB9O1xuICBsZXQgZGlkVW5zdWJzY3JpYmUgPSBmYWxzZTtcbiAgbGV0IGxhc3RUaHJvd25FcnJvciA9IG51bGw7XG4gIGNvbnN0IGNoZWNrRm9yVXBkYXRlcyA9ICgpID0+IHtcbiAgICBpZiAoZGlkVW5zdWJzY3JpYmUgfHwgIWlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhdGVzdFN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGxldCBuZXdDaGlsZFByb3BzLCBlcnJvcjtcbiAgICB0cnkge1xuICAgICAgbmV3Q2hpbGRQcm9wcyA9IGNoaWxkUHJvcHNTZWxlY3RvcihcbiAgICAgICAgbGF0ZXN0U3RvcmVTdGF0ZSxcbiAgICAgICAgbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yID0gZTtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IGU7XG4gICAgfVxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuZXdDaGlsZFByb3BzID09PSBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50KSB7XG4gICAgICBpZiAoIXJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQpIHtcbiAgICAgICAgbm90aWZ5TmVzdGVkU3VicygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wcztcbiAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IG5ld0NoaWxkUHJvcHM7XG4gICAgICByZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lcigpO1xuICAgIH1cbiAgfTtcbiAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBjaGVja0ZvclVwZGF0ZXM7XG4gIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcbiAgY2hlY2tGb3JVcGRhdGVzKCk7XG4gIGNvbnN0IHVuc3Vic2NyaWJlV3JhcHBlciA9ICgpID0+IHtcbiAgICBkaWRVbnN1YnNjcmliZSA9IHRydWU7XG4gICAgc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBudWxsO1xuICAgIGlmIChsYXN0VGhyb3duRXJyb3IpIHtcbiAgICAgIHRocm93IGxhc3RUaHJvd25FcnJvcjtcbiAgICB9XG4gIH07XG4gIHJldHVybiB1bnN1YnNjcmliZVdyYXBwZXI7XG59XG5mdW5jdGlvbiBzdHJpY3RFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24gPSBmYWxzZTtcbmZ1bmN0aW9uIGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIHtcbiAgLy8gVGhlIGBwdXJlYCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZCwgc28gVFMgZG9lc24ndCBsaWtlIHVzIGRlc3RydWN0dXJpbmcgdGhpcyB0byBjaGVjayBpdHMgZXhpc3RlbmNlLlxuICAvLyBAdHMtaWdub3JlXG4gIHB1cmUsXG4gIGFyZVN0YXRlc0VxdWFsID0gc3RyaWN0RXF1YWwsXG4gIGFyZU93blByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgYXJlTWVyZ2VkUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgLy8gdXNlIFJlYWN0J3MgZm9yd2FyZFJlZiB0byBleHBvc2UgYSByZWYgb2YgdGhlIHdyYXBwZWQgY29tcG9uZW50XG4gIGZvcndhcmRSZWYgPSBmYWxzZSxcbiAgLy8gdGhlIGNvbnRleHQgY29uc3VtZXIgdG8gdXNlXG4gIGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dFxufSA9IHt9KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAocHVyZSAhPT0gdm9pZCAwICYmICFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgICdUaGUgYHB1cmVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLiBgY29ubmVjdGAgaXMgbm93IGFsd2F5cyBhIFwicHVyZS9tZW1vaXplZFwiIGNvbXBvbmVudCdcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IENvbnRleHQgPSBjb250ZXh0O1xuICBjb25zdCBpbml0TWFwU3RhdGVUb1Byb3BzID0gbWFwU3RhdGVUb1Byb3BzRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMpO1xuICBjb25zdCBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMpO1xuICBjb25zdCBpbml0TWVyZ2VQcm9wcyA9IG1lcmdlUHJvcHNGYWN0b3J5KG1lcmdlUHJvcHMpO1xuICBjb25zdCBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMgPSBCb29sZWFuKG1hcFN0YXRlVG9Qcm9wcyk7XG4gIGNvbnN0IHdyYXBXaXRoQ29ubmVjdCA9IChXcmFwcGVkQ29tcG9uZW50KSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc3QgaXNWYWxpZCA9IC8qIEBfX1BVUkVfXyAqLyBpc1ZhbGlkRWxlbWVudFR5cGUoV3JhcHBlZENvbXBvbmVudCk7XG4gICAgICBpZiAoIWlzVmFsaWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgWW91IG11c3QgcGFzcyBhIGNvbXBvbmVudCB0byB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgY29ubmVjdC4gSW5zdGVhZCByZWNlaXZlZCAke3N0cmluZ2lmeUNvbXBvbmVudChcbiAgICAgICAgICAgIFdyYXBwZWRDb21wb25lbnRcbiAgICAgICAgICApfWBcbiAgICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgd3JhcHBlZENvbXBvbmVudE5hbWUgPSBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCBcIkNvbXBvbmVudFwiO1xuICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gYENvbm5lY3QoJHt3cmFwcGVkQ29tcG9uZW50TmFtZX0pYDtcbiAgICBjb25zdCBzZWxlY3RvckZhY3RvcnlPcHRpb25zID0ge1xuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgZGlzcGxheU5hbWUsXG4gICAgICB3cmFwcGVkQ29tcG9uZW50TmFtZSxcbiAgICAgIFdyYXBwZWRDb21wb25lbnQsXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICAgICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgICAgIGluaXRNZXJnZVByb3BzLFxuICAgICAgYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVTdGF0ZVByb3BzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlTWVyZ2VkUHJvcHNFcXVhbFxuICAgIH07XG4gICAgZnVuY3Rpb24gQ29ubmVjdEZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICBjb25zdCBbcHJvcHNDb250ZXh0LCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCB3cmFwcGVyUHJvcHNdID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjogcmVhY3RSZWR1eEZvcndhcmRlZFJlZjIsIC4uLndyYXBwZXJQcm9wczIgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gW3Byb3BzLmNvbnRleHQsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYyLCB3cmFwcGVyUHJvcHMyXTtcbiAgICAgIH0sIFtwcm9wc10pO1xuICAgICAgY29uc3QgQ29udGV4dFRvVXNlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGxldCBSZXN1bHRDb250ZXh0ID0gQ29udGV4dDtcbiAgICAgICAgaWYgKHByb3BzQ29udGV4dD8uQ29uc3VtZXIpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gLyogQF9fUFVSRV9fICovIGlzQ29udGV4dENvbnN1bWVyKFxuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KHByb3BzQ29udGV4dC5Db25zdW1lciwgbnVsbClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiWW91IG11c3QgcGFzcyBhIHZhbGlkIFJlYWN0IGNvbnRleHQgY29uc3VtZXIgYXMgYHByb3BzLmNvbnRleHRgXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlc3VsdENvbnRleHQgPSBwcm9wc0NvbnRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZXN1bHRDb250ZXh0O1xuICAgICAgfSwgW3Byb3BzQ29udGV4dCwgQ29udGV4dF0pO1xuICAgICAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlQ29udGV4dChDb250ZXh0VG9Vc2UpO1xuICAgICAgY29uc3QgZGlkU3RvcmVDb21lRnJvbVByb3BzID0gQm9vbGVhbihwcm9wcy5zdG9yZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5nZXRTdGF0ZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5kaXNwYXRjaCk7XG4gICAgICBjb25zdCBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA9IEJvb2xlYW4oY29udGV4dFZhbHVlKSAmJiBCb29sZWFuKGNvbnRleHRWYWx1ZS5zdG9yZSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFkaWRTdG9yZUNvbWVGcm9tUHJvcHMgJiYgIWRpZFN0b3JlQ29tZUZyb21Db250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ291bGQgbm90IGZpbmQgXCJzdG9yZVwiIGluIHRoZSBjb250ZXh0IG9mIFwiJHtkaXNwbGF5TmFtZX1cIi4gRWl0aGVyIHdyYXAgdGhlIHJvb3QgY29tcG9uZW50IGluIGEgPFByb3ZpZGVyPiwgb3IgcGFzcyBhIGN1c3RvbSBSZWFjdCBjb250ZXh0IHByb3ZpZGVyIHRvIDxQcm92aWRlcj4gYW5kIHRoZSBjb3JyZXNwb25kaW5nIFJlYWN0IGNvbnRleHQgY29uc3VtZXIgdG8gJHtkaXNwbGF5TmFtZX0gaW4gY29ubmVjdCBvcHRpb25zLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JlID0gZGlkU3RvcmVDb21lRnJvbVByb3BzID8gcHJvcHMuc3RvcmUgOiBjb250ZXh0VmFsdWUuc3RvcmU7XG4gICAgICBjb25zdCBnZXRTZXJ2ZXJTdGF0ZSA9IGRpZFN0b3JlQ29tZUZyb21Db250ZXh0ID8gY29udGV4dFZhbHVlLmdldFNlcnZlclN0YXRlIDogc3RvcmUuZ2V0U3RhdGU7XG4gICAgICBjb25zdCBjaGlsZFByb3BzU2VsZWN0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGZpbmFsUHJvcHNTZWxlY3RvckZhY3Rvcnkoc3RvcmUuZGlzcGF0Y2gsIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMpO1xuICAgICAgfSwgW3N0b3JlXSk7XG4gICAgICBjb25zdCBbc3Vic2NyaXB0aW9uLCBub3RpZnlOZXN0ZWRTdWJzXSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuIE5PX1NVQlNDUklQVElPTl9BUlJBWTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uMiA9IGNyZWF0ZVN1YnNjcmlwdGlvbihcbiAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPyB2b2lkIDAgOiBjb250ZXh0VmFsdWUuc3Vic2NyaXB0aW9uXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG5vdGlmeU5lc3RlZFN1YnMyID0gc3Vic2NyaXB0aW9uMi5ub3RpZnlOZXN0ZWRTdWJzLmJpbmQoc3Vic2NyaXB0aW9uMik7XG4gICAgICAgIHJldHVybiBbc3Vic2NyaXB0aW9uMiwgbm90aWZ5TmVzdGVkU3ViczJdO1xuICAgICAgfSwgW3N0b3JlLCBkaWRTdG9yZUNvbWVGcm9tUHJvcHMsIGNvbnRleHRWYWx1ZV0pO1xuICAgICAgY29uc3Qgb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoZGlkU3RvcmVDb21lRnJvbVByb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmNvbnRleHRWYWx1ZSxcbiAgICAgICAgICBzdWJzY3JpcHRpb25cbiAgICAgICAgfTtcbiAgICAgIH0sIFtkaWRTdG9yZUNvbWVGcm9tUHJvcHMsIGNvbnRleHRWYWx1ZSwgc3Vic2NyaXB0aW9uXSk7XG4gICAgICBjb25zdCBsYXN0Q2hpbGRQcm9wcyA9IFJlYWN0LnVzZVJlZih2b2lkIDApO1xuICAgICAgY29uc3QgbGFzdFdyYXBwZXJQcm9wcyA9IFJlYWN0LnVzZVJlZih3cmFwcGVyUHJvcHMpO1xuICAgICAgY29uc3QgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSA9IFJlYWN0LnVzZVJlZih2b2lkIDApO1xuICAgICAgY29uc3QgcmVuZGVySXNTY2hlZHVsZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgICAgY29uc3QgaXNNb3VudGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICAgIGNvbnN0IGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IgPSBSZWFjdC51c2VSZWYoXG4gICAgICAgIHZvaWQgMFxuICAgICAgKTtcbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgIH0sIFtdKTtcbiAgICAgIGNvbnN0IGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ICYmIHdyYXBwZXJQcm9wcyA9PT0gbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2hpbGRQcm9wc1NlbGVjdG9yKHN0b3JlLmdldFN0YXRlKCksIHdyYXBwZXJQcm9wcyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICAgIH0sIFtzdG9yZSwgd3JhcHBlclByb3BzXSk7XG4gICAgICBjb25zdCBzdWJzY3JpYmVGb3JSZWFjdCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzdWJzY3JpYmUgPSAocmVhY3RMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN1YnNjcmliZVVwZGF0ZXMoXG4gICAgICAgICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNoaWxkUHJvcHNTZWxlY3RvcixcbiAgICAgICAgICAgIGxhc3RXcmFwcGVyUHJvcHMsXG4gICAgICAgICAgICBsYXN0Q2hpbGRQcm9wcyxcbiAgICAgICAgICAgIHJlbmRlcklzU2NoZWR1bGVkLFxuICAgICAgICAgICAgaXNNb3VudGVkLFxuICAgICAgICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSxcbiAgICAgICAgICAgIG5vdGlmeU5lc3RlZFN1YnMsXG4gICAgICAgICAgICByZWFjdExpc3RlbmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZTtcbiAgICAgIH0sIFtzdWJzY3JpcHRpb25dKTtcbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyhjYXB0dXJlV3JhcHBlclByb3BzLCBbXG4gICAgICAgIGxhc3RXcmFwcGVyUHJvcHMsXG4gICAgICAgIGxhc3RDaGlsZFByb3BzLFxuICAgICAgICByZW5kZXJJc1NjaGVkdWxlZCxcbiAgICAgICAgd3JhcHBlclByb3BzLFxuICAgICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLFxuICAgICAgICBub3RpZnlOZXN0ZWRTdWJzXG4gICAgICBdKTtcbiAgICAgIGxldCBhY3R1YWxDaGlsZFByb3BzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWN0dWFsQ2hpbGRQcm9wcyA9IFJlYWN0LnVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIC8vIFRPRE8gV2UncmUgcGFzc2luZyB0aHJvdWdoIGEgYmlnIHdyYXBwZXIgdGhhdCBkb2VzIGEgYnVuY2ggb2YgZXh0cmEgc2lkZSBlZmZlY3RzIGJlc2lkZXMgc3Vic2NyaWJpbmdcbiAgICAgICAgICBzdWJzY3JpYmVGb3JSZWFjdCxcbiAgICAgICAgICAvLyBUT0RPIFRoaXMgaXMgaW5jcmVkaWJseSBoYWNreS4gV2UndmUgYWxyZWFkeSBwcm9jZXNzZWQgdGhlIHN0b3JlIHVwZGF0ZSBhbmQgY2FsY3VsYXRlZCBuZXcgY2hpbGQgcHJvcHMsXG4gICAgICAgICAgLy8gVE9ETyBhbmQgd2UncmUganVzdCBwYXNzaW5nIHRoYXQgdGhyb3VnaCBzbyBpdCB0cmlnZ2VycyBhIHJlLXJlbmRlciBmb3IgdXMgcmF0aGVyIHRoYW4gcmVseWluZyBvbiBgdVNFU2AuXG4gICAgICAgICAgYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yLFxuICAgICAgICAgIGdldFNlcnZlclN0YXRlID8gKCkgPT4gY2hpbGRQcm9wc1NlbGVjdG9yKGdldFNlcnZlclN0YXRlKCksIHdyYXBwZXJQcm9wcykgOiBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3JcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAobGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50KSB7XG4gICAgICAgICAgO1xuICAgICAgICAgIGVyci5tZXNzYWdlICs9IGBcblRoZSBlcnJvciBtYXkgYmUgY29ycmVsYXRlZCB3aXRoIHRoaXMgcHJldmlvdXMgZXJyb3I6XG4ke2xhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudC5zdGFja31cblxuYDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ID0gdm9pZCAwO1xuICAgICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICAgIGxhc3RDaGlsZFByb3BzLmN1cnJlbnQgPSBhY3R1YWxDaGlsZFByb3BzO1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBXcmFwcGVkQ29tcG9uZW50LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi5hY3R1YWxDaGlsZFByb3BzLFxuICAgICAgICAgICAgICByZWY6IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9LCBbcmVhY3RSZWR1eEZvcndhcmRlZFJlZiwgV3JhcHBlZENvbXBvbmVudCwgYWN0dWFsQ2hpbGRQcm9wc10pO1xuICAgICAgY29uc3QgcmVuZGVyZWRDaGlsZCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSB7XG4gICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRUb1VzZS5Qcm92aWRlciwgeyB2YWx1ZTogb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZSB9LCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQ7XG4gICAgICB9LCBbQ29udGV4dFRvVXNlLCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQsIG92ZXJyaWRkZW5Db250ZXh0VmFsdWVdKTtcbiAgICAgIHJldHVybiByZW5kZXJlZENoaWxkO1xuICAgIH1cbiAgICBjb25zdCBfQ29ubmVjdCA9IFJlYWN0Lm1lbW8oQ29ubmVjdEZ1bmN0aW9uKTtcbiAgICBjb25zdCBDb25uZWN0ID0gX0Nvbm5lY3Q7XG4gICAgQ29ubmVjdC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICBDb25uZWN0LmRpc3BsYXlOYW1lID0gQ29ubmVjdEZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgaWYgKGZvcndhcmRSZWYpIHtcbiAgICAgIGNvbnN0IF9mb3J3YXJkZWQgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkQ29ubmVjdFJlZihwcm9wcywgcmVmKSB7XG4gICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbm5lY3QsIHsgLi4ucHJvcHMsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWY6IHJlZiB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGZvcndhcmRlZCA9IF9mb3J3YXJkZWQ7XG4gICAgICBmb3J3YXJkZWQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICAgIGZvcndhcmRlZC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaG9pc3ROb25SZWFjdFN0YXRpY3MoZm9yd2FyZGVkLCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBob2lzdE5vblJlYWN0U3RhdGljcyhDb25uZWN0LCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgfTtcbiAgcmV0dXJuIHdyYXBXaXRoQ29ubmVjdDtcbn1cbnZhciBjb25uZWN0X2RlZmF1bHQgPSBjb25uZWN0O1xuXG4vLyBzcmMvY29tcG9uZW50cy9Qcm92aWRlci50c3hcbmZ1bmN0aW9uIFByb3ZpZGVyKHByb3ZpZGVyUHJvcHMpIHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgY29udGV4dCwgc2VydmVyU3RhdGUsIHN0b3JlIH0gPSBwcm92aWRlclByb3BzO1xuICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBjcmVhdGVTdWJzY3JpcHRpb24oc3RvcmUpO1xuICAgIGNvbnN0IGJhc2VDb250ZXh0VmFsdWUgPSB7XG4gICAgICBzdG9yZSxcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIGdldFNlcnZlclN0YXRlOiBzZXJ2ZXJTdGF0ZSA/ICgpID0+IHNlcnZlclN0YXRlIDogdm9pZCAwXG4gICAgfTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZXR1cm4gYmFzZUNvbnRleHRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyBpZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPSBcIm9uY2VcIiwgc3RhYmlsaXR5Q2hlY2sgPSBcIm9uY2VcIiB9ID0gcHJvdmlkZXJQcm9wcztcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmFzc2lnbihiYXNlQ29udGV4dFZhbHVlLCB7XG4gICAgICAgIHN0YWJpbGl0eUNoZWNrLFxuICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2tcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW3N0b3JlLCBzZXJ2ZXJTdGF0ZV0pO1xuICBjb25zdCBwcmV2aW91c1N0YXRlID0gUmVhY3QudXNlTWVtbygoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLCBbc3RvcmVdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgeyBzdWJzY3JpcHRpb24gfSA9IGNvbnRleHRWYWx1ZTtcbiAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IHN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzO1xuICAgIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcbiAgICBpZiAocHJldmlvdXNTdGF0ZSAhPT0gc3RvcmUuZ2V0U3RhdGUoKSkge1xuICAgICAgc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSB2b2lkIDA7XG4gICAgfTtcbiAgfSwgW2NvbnRleHRWYWx1ZSwgcHJldmlvdXNTdGF0ZV0pO1xuICBjb25zdCBDb250ZXh0ID0gY29udGV4dCB8fCBSZWFjdFJlZHV4Q29udGV4dDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHRWYWx1ZSB9LCBjaGlsZHJlbik7XG59XG52YXIgUHJvdmlkZXJfZGVmYXVsdCA9IFByb3ZpZGVyO1xuXG4vLyBzcmMvaG9va3MvdXNlUmVkdXhDb250ZXh0LnRzXG5mdW5jdGlvbiBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24gdXNlUmVkdXhDb250ZXh0MigpIHtcbiAgICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWNvbnRleHRWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcImNvdWxkIG5vdCBmaW5kIHJlYWN0LXJlZHV4IGNvbnRleHQgdmFsdWU7IHBsZWFzZSBlbnN1cmUgdGhlIGNvbXBvbmVudCBpcyB3cmFwcGVkIGluIGEgPFByb3ZpZGVyPlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dFZhbHVlO1xuICB9O1xufVxudmFyIHVzZVJlZHV4Q29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVSZWR1eENvbnRleHRIb29rKCk7XG5cbi8vIHNyYy9ob29rcy91c2VTdG9yZS50c1xuZnVuY3Rpb24gY3JlYXRlU3RvcmVIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICBjb25zdCB1c2VSZWR1eENvbnRleHQyID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VSZWR1eENvbnRleHQgOiAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dClcbiAgKTtcbiAgY29uc3QgdXNlU3RvcmUyID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgc3RvcmUgfSA9IHVzZVJlZHV4Q29udGV4dDIoKTtcbiAgICByZXR1cm4gc3RvcmU7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odXNlU3RvcmUyLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VTdG9yZTJcbiAgfSk7XG4gIHJldHVybiB1c2VTdG9yZTI7XG59XG52YXIgdXNlU3RvcmUgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU3RvcmVIb29rKCk7XG5cbi8vIHNyYy9ob29rcy91c2VEaXNwYXRjaC50c1xuZnVuY3Rpb24gY3JlYXRlRGlzcGF0Y2hIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICBjb25zdCB1c2VTdG9yZTIgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZVN0b3JlIDogY3JlYXRlU3RvcmVIb29rKGNvbnRleHQpO1xuICBjb25zdCB1c2VEaXNwYXRjaDIgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZTIoKTtcbiAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2g7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odXNlRGlzcGF0Y2gyLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VEaXNwYXRjaDJcbiAgfSk7XG4gIHJldHVybiB1c2VEaXNwYXRjaDI7XG59XG52YXIgdXNlRGlzcGF0Y2ggPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGlzcGF0Y2hIb29rKCk7XG5cbi8vIHNyYy9ob29rcy91c2VTZWxlY3Rvci50c1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvd2l0aC1zZWxlY3Rvci5qc1wiO1xudmFyIHJlZkVxdWFsaXR5ID0gKGEsIGIpID0+IGEgPT09IGI7XG5mdW5jdGlvbiBjcmVhdGVTZWxlY3Rvckhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVJlZHV4Q29udGV4dDIgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZVJlZHV4Q29udGV4dCA6IGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dCk7XG4gIGNvbnN0IHVzZVNlbGVjdG9yMiA9IChzZWxlY3RvciwgZXF1YWxpdHlGbk9yT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgeyBlcXVhbGl0eUZuID0gcmVmRXF1YWxpdHkgfSA9IHR5cGVvZiBlcXVhbGl0eUZuT3JPcHRpb25zID09PSBcImZ1bmN0aW9uXCIgPyB7IGVxdWFsaXR5Rm46IGVxdWFsaXR5Rm5Pck9wdGlvbnMgfSA6IGVxdWFsaXR5Rm5Pck9wdGlvbnM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBzZWxlY3RvciB0byB1c2VTZWxlY3RvcmApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIGZ1bmN0aW9uIGFzIGEgc2VsZWN0b3IgdG8gdXNlU2VsZWN0b3JgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZXF1YWxpdHlGbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgWW91IG11c3QgcGFzcyBhIGZ1bmN0aW9uIGFzIGFuIGVxdWFsaXR5IGZ1bmN0aW9uIHRvIHVzZVNlbGVjdG9yYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZWR1eENvbnRleHQgPSB1c2VSZWR1eENvbnRleHQyKCk7XG4gICAgY29uc3QgeyBzdG9yZSwgc3Vic2NyaXB0aW9uLCBnZXRTZXJ2ZXJTdGF0ZSB9ID0gcmVkdXhDb250ZXh0O1xuICAgIGNvbnN0IGZpcnN0UnVuID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICAgIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAge1xuICAgICAgICBbc2VsZWN0b3IubmFtZV0oc3RhdGUpIHtcbiAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHNlbGVjdG9yKHN0YXRlKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRldk1vZGVDaGVja3MgPSB7fSB9ID0gdHlwZW9mIGVxdWFsaXR5Rm5Pck9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHt9IDogZXF1YWxpdHlGbk9yT3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHsgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLCBzdGFiaWxpdHlDaGVjayB9ID0gcmVkdXhDb250ZXh0O1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6IGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrLFxuICAgICAgICAgICAgICBzdGFiaWxpdHlDaGVjazogZmluYWxTdGFiaWxpdHlDaGVja1xuICAgICAgICAgICAgfSA9IHtcbiAgICAgICAgICAgICAgc3RhYmlsaXR5Q2hlY2ssXG4gICAgICAgICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVjayxcbiAgICAgICAgICAgICAgLi4uZGV2TW9kZUNoZWNrc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChmaW5hbFN0YWJpbGl0eUNoZWNrID09PSBcImFsd2F5c1wiIHx8IGZpbmFsU3RhYmlsaXR5Q2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgY29uc3QgdG9Db21wYXJlID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgICAgICAgICBpZiAoIWVxdWFsaXR5Rm4oc2VsZWN0ZWQsIHRvQ29tcGFyZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2sgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICh7IHN0YWNrIH0gPSBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgXCJTZWxlY3RvciBcIiArIChzZWxlY3Rvci5uYW1lIHx8IFwidW5rbm93blwiKSArIFwiIHJldHVybmVkIGEgZGlmZmVyZW50IHJlc3VsdCB3aGVuIGNhbGxlZCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcmVyZW5kZXJzLlxcblNlbGVjdG9ycyB0aGF0IHJldHVybiBhIG5ldyByZWZlcmVuY2UgKHN1Y2ggYXMgYW4gb2JqZWN0IG9yIGFuIGFycmF5KSBzaG91bGQgYmUgbWVtb2l6ZWQ6IGh0dHBzOi8vcmVkdXguanMub3JnL3VzYWdlL2Rlcml2aW5nLWRhdGEtc2VsZWN0b3JzI29wdGltaXppbmctc2VsZWN0b3JzLXdpdGgtbWVtb2l6YXRpb25cIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDI6IHRvQ29tcGFyZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPT09IFwiYWx3YXlzXCIgfHwgZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgKHsgc3RhY2sgfSA9IGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBcIlNlbGVjdG9yIFwiICsgKHNlbGVjdG9yLm5hbWUgfHwgXCJ1bmtub3duXCIpICsgXCIgcmV0dXJuZWQgdGhlIHJvb3Qgc3RhdGUgd2hlbiBjYWxsZWQuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcmVyZW5kZXJzLlxcblNlbGVjdG9ycyB0aGF0IHJldHVybiB0aGUgZW50aXJlIHN0YXRlIGFyZSBhbG1vc3QgY2VydGFpbmx5IGEgbWlzdGFrZSwgYXMgdGhleSB3aWxsIGNhdXNlIGEgcmVyZW5kZXIgd2hlbmV2ZXIgKmFueXRoaW5nKiBpbiBzdGF0ZSBjaGFuZ2VzLlwiLFxuICAgICAgICAgICAgICAgICAgeyBzdGFjayB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0UnVuLmN1cnJlbnQpIGZpcnN0UnVuLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICB9W3NlbGVjdG9yLm5hbWVdLFxuICAgICAgW3NlbGVjdG9yXVxuICAgICk7XG4gICAgY29uc3Qgc2VsZWN0ZWRTdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgICAgc3Vic2NyaXB0aW9uLmFkZE5lc3RlZFN1YixcbiAgICAgIHN0b3JlLmdldFN0YXRlLFxuICAgICAgZ2V0U2VydmVyU3RhdGUgfHwgc3RvcmUuZ2V0U3RhdGUsXG4gICAgICB3cmFwcGVkU2VsZWN0b3IsXG4gICAgICBlcXVhbGl0eUZuXG4gICAgKTtcbiAgICBSZWFjdC51c2VEZWJ1Z1ZhbHVlKHNlbGVjdGVkU3RhdGUpO1xuICAgIHJldHVybiBzZWxlY3RlZFN0YXRlO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHVzZVNlbGVjdG9yMiwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gdXNlU2VsZWN0b3IyXG4gIH0pO1xuICByZXR1cm4gdXNlU2VsZWN0b3IyO1xufVxudmFyIHVzZVNlbGVjdG9yID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVNlbGVjdG9ySG9vaygpO1xuXG4vLyBzcmMvZXhwb3J0cy50c1xudmFyIGJhdGNoID0gZGVmYXVsdE5vb3BCYXRjaDtcbmV4cG9ydCB7XG4gIFByb3ZpZGVyX2RlZmF1bHQgYXMgUHJvdmlkZXIsXG4gIFJlYWN0UmVkdXhDb250ZXh0LFxuICBiYXRjaCxcbiAgY29ubmVjdF9kZWZhdWx0IGFzIGNvbm5lY3QsXG4gIGNyZWF0ZURpc3BhdGNoSG9vayxcbiAgY3JlYXRlU2VsZWN0b3JIb29rLFxuICBjcmVhdGVTdG9yZUhvb2ssXG4gIHNoYWxsb3dFcXVhbCxcbiAgdXNlRGlzcGF0Y2gsXG4gIHVzZVNlbGVjdG9yLFxuICB1c2VTdG9yZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXJlZHV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiUmVhY3QiLCJJU19SRUFDVF8xOSIsInZlcnNpb24iLCJzdGFydHNXaXRoIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiU3ltYm9sIiwiZm9yIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9DT05TVU1FUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UiLCJGb3J3YXJkUmVmIiwiTWVtbyIsImlzVmFsaWRFbGVtZW50VHlwZSIsInR5cGUiLCIkJHR5cGVvZiIsImdldE1vZHVsZUlkIiwidHlwZU9mIiwib2JqZWN0IiwiaXNDb250ZXh0Q29uc3VtZXIiLCJpc01lbW8iLCJ3YXJuaW5nIiwibWVzc2FnZSIsImNvbnNvbGUiLCJlcnJvciIsIkVycm9yIiwiZSIsInZlcmlmeSIsInNlbGVjdG9yIiwibWV0aG9kTmFtZSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInZlcmlmeVN1YnNlbGVjdG9ycyIsIm1hcFN0YXRlVG9Qcm9wcyIsIm1hcERpc3BhdGNoVG9Qcm9wcyIsIm1lcmdlUHJvcHMiLCJwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSIsImRpc3BhdGNoIiwiYXJlU3RhdGVzRXF1YWwiLCJhcmVPd25Qcm9wc0VxdWFsIiwiYXJlU3RhdGVQcm9wc0VxdWFsIiwiaGFzUnVuQXRMZWFzdE9uY2UiLCJzdGF0ZSIsIm93blByb3BzIiwic3RhdGVQcm9wcyIsImRpc3BhdGNoUHJvcHMiLCJtZXJnZWRQcm9wcyIsImhhbmRsZUZpcnN0Q2FsbCIsImZpcnN0U3RhdGUiLCJmaXJzdE93blByb3BzIiwiaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSIsImRlcGVuZHNPbk93blByb3BzIiwiaGFuZGxlTmV3UHJvcHMiLCJoYW5kbGVOZXdTdGF0ZSIsIm5leHRTdGF0ZVByb3BzIiwic3RhdGVQcm9wc0NoYW5nZWQiLCJoYW5kbGVTdWJzZXF1ZW50Q2FsbHMiLCJuZXh0U3RhdGUiLCJuZXh0T3duUHJvcHMiLCJwcm9wc0NoYW5nZWQiLCJzdGF0ZUNoYW5nZWQiLCJwdXJlRmluYWxQcm9wc1NlbGVjdG9yIiwiZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSIsImluaXRNYXBTdGF0ZVRvUHJvcHMiLCJpbml0TWFwRGlzcGF0Y2hUb1Byb3BzIiwiaW5pdE1lcmdlUHJvcHMiLCJvcHRpb25zIiwicHJvY2VzcyIsImJpbmRBY3Rpb25DcmVhdG9ycyIsImFjdGlvbkNyZWF0b3JzIiwiYm91bmRBY3Rpb25DcmVhdG9ycyIsImtleSIsImFjdGlvbkNyZWF0b3IiLCJhcmdzIiwiaXNQbGFpbk9iamVjdCIsIm9iaiIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJiYXNlUHJvdG8iLCJ2ZXJpZnlQbGFpbk9iamVjdCIsInZhbHVlIiwiZGlzcGxheU5hbWUiLCJ3cmFwTWFwVG9Qcm9wc0NvbnN0YW50IiwiZ2V0Q29uc3RhbnQiLCJpbml0Q29uc3RhbnRTZWxlY3RvciIsImNvbnN0YW50IiwiY29uc3RhbnRTZWxlY3RvciIsImdldERlcGVuZHNPbk93blByb3BzIiwibWFwVG9Qcm9wcyIsIkJvb2xlYW4iLCJsZW5ndGgiLCJ3cmFwTWFwVG9Qcm9wc0Z1bmMiLCJpbml0UHJveHlTZWxlY3RvciIsInByb3h5IiwibWFwVG9Qcm9wc1Byb3h5Iiwic3RhdGVPckRpc3BhdGNoIiwiZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeSIsInByb3BzIiwiY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkiLCJhcmciLCJuYW1lIiwid3JhcHBlZENvbXBvbmVudE5hbWUiLCJtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5IiwibWFwU3RhdGVUb1Byb3BzRmFjdG9yeSIsImRlZmF1bHRNZXJnZVByb3BzIiwid3JhcE1lcmdlUHJvcHNGdW5jIiwiaW5pdE1lcmdlUHJvcHNQcm94eSIsImFyZU1lcmdlZFByb3BzRXF1YWwiLCJoYXNSdW5PbmNlIiwibWVyZ2VQcm9wc1Byb3h5IiwibmV4dE1lcmdlZFByb3BzIiwibWVyZ2VQcm9wc0ZhY3RvcnkiLCJkZWZhdWx0Tm9vcEJhdGNoIiwiY2FsbGJhY2siLCJjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24iLCJmaXJzdCIsImxhc3QiLCJjbGVhciIsIm5vdGlmeSIsImxpc3RlbmVyIiwibmV4dCIsImdldCIsImxpc3RlbmVycyIsInB1c2giLCJzdWJzY3JpYmUiLCJpc1N1YnNjcmliZWQiLCJwcmV2IiwidW5zdWJzY3JpYmUiLCJudWxsTGlzdGVuZXJzIiwiY3JlYXRlU3Vic2NyaXB0aW9uIiwic3RvcmUiLCJwYXJlbnRTdWIiLCJzdWJzY3JpcHRpb25zQW1vdW50Iiwic2VsZlN1YnNjcmliZWQiLCJhZGROZXN0ZWRTdWIiLCJ0cnlTdWJzY3JpYmUiLCJjbGVhbnVwTGlzdGVuZXIiLCJyZW1vdmVkIiwidHJ5VW5zdWJzY3JpYmUiLCJub3RpZnlOZXN0ZWRTdWJzIiwiaGFuZGxlQ2hhbmdlV3JhcHBlciIsInN1YnNjcmlwdGlvbiIsIm9uU3RhdGVDaGFuZ2UiLCJ0cnlTdWJzY3JpYmVTZWxmIiwidHJ5VW5zdWJzY3JpYmVTZWxmIiwiZ2V0TGlzdGVuZXJzIiwiY2FuVXNlRE9NIiwid2luZG93IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaXNET00iLCJpc1J1bm5pbmdJblJlYWN0TmF0aXZlIiwibmF2aWdhdG9yIiwicHJvZHVjdCIsImlzUmVhY3ROYXRpdmUiLCJnZXRVc2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsImlzIiwieCIsInkiLCJzaGFsbG93RXF1YWwiLCJvYmpBIiwib2JqQiIsImtleXNBIiwia2V5cyIsImtleXNCIiwiaSIsIlJFQUNUX1NUQVRJQ1MiLCJjaGlsZENvbnRleHRUeXBlcyIsImNvbnRleHRUeXBlIiwiY29udGV4dFR5cGVzIiwiZGVmYXVsdFByb3BzIiwiZ2V0RGVmYXVsdFByb3BzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwibWl4aW5zIiwicHJvcFR5cGVzIiwiS05PV05fU1RBVElDUyIsImNhbGxlciIsImNhbGxlZSIsImFyZ3VtZW50cyIsImFyaXR5IiwiRk9SV0FSRF9SRUZfU1RBVElDUyIsInJlbmRlciIsIk1FTU9fU1RBVElDUyIsImNvbXBhcmUiLCJUWVBFX1NUQVRJQ1MiLCJnZXRTdGF0aWNzIiwiY29tcG9uZW50IiwiZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwib2JqZWN0UHJvdG90eXBlIiwiaG9pc3ROb25SZWFjdFN0YXRpY3MiLCJ0YXJnZXRDb21wb25lbnQiLCJzb3VyY2VDb21wb25lbnQiLCJpbmhlcml0ZWRDb21wb25lbnQiLCJjb25jYXQiLCJ0YXJnZXRTdGF0aWNzIiwic291cmNlU3RhdGljcyIsImRlc2NyaXB0b3IiLCJDb250ZXh0S2V5IiwiZ1QiLCJnbG9iYWxUaGlzIiwiZ2V0Q29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJjb250ZXh0TWFwIiwiTWFwIiwicmVhbENvbnRleHQiLCJzZXQiLCJSZWFjdFJlZHV4Q29udGV4dCIsIk5PX1NVQlNDUklQVElPTl9BUlJBWSIsInN0cmluZ2lmeUNvbXBvbmVudCIsIkNvbXAiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyIiwiU3RyaW5nIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzIiwiZWZmZWN0RnVuYyIsImVmZmVjdEFyZ3MiLCJkZXBlbmRlbmNpZXMiLCJjYXB0dXJlV3JhcHBlclByb3BzIiwibGFzdFdyYXBwZXJQcm9wcyIsImxhc3RDaGlsZFByb3BzIiwicmVuZGVySXNTY2hlZHVsZWQiLCJ3cmFwcGVyUHJvcHMiLCJjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlIiwiY3VycmVudCIsInN1YnNjcmliZVVwZGF0ZXMiLCJzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMiLCJjaGlsZFByb3BzU2VsZWN0b3IiLCJpc01vdW50ZWQiLCJhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIiLCJkaWRVbnN1YnNjcmliZSIsImxhc3RUaHJvd25FcnJvciIsImNoZWNrRm9yVXBkYXRlcyIsImxhdGVzdFN0b3JlU3RhdGUiLCJnZXRTdGF0ZSIsIm5ld0NoaWxkUHJvcHMiLCJ1bnN1YnNjcmliZVdyYXBwZXIiLCJzdHJpY3RFcXVhbCIsImEiLCJiIiwiaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbiIsImNvbm5lY3QiLCJwdXJlIiwiZm9yd2FyZFJlZiIsImNvbnRleHQiLCJDb250ZXh0Iiwid3JhcFdpdGhDb25uZWN0IiwiV3JhcHBlZENvbXBvbmVudCIsImlzVmFsaWQiLCJzZWxlY3RvckZhY3RvcnlPcHRpb25zIiwiQ29ubmVjdEZ1bmN0aW9uIiwicHJvcHNDb250ZXh0IiwicmVhY3RSZWR1eEZvcndhcmRlZFJlZiIsInVzZU1lbW8iLCJyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmMiIsIndyYXBwZXJQcm9wczIiLCJDb250ZXh0VG9Vc2UiLCJSZXN1bHRDb250ZXh0IiwiQ29uc3VtZXIiLCJjb250ZXh0VmFsdWUiLCJ1c2VDb250ZXh0IiwiZGlkU3RvcmVDb21lRnJvbVByb3BzIiwiZGlkU3RvcmVDb21lRnJvbUNvbnRleHQiLCJnZXRTZXJ2ZXJTdGF0ZSIsInN1YnNjcmlwdGlvbjIiLCJub3RpZnlOZXN0ZWRTdWJzMiIsImJpbmQiLCJvdmVycmlkZGVuQ29udGV4dFZhbHVlIiwidXNlUmVmIiwibGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciIsImFjdHVhbENoaWxkUHJvcHNTZWxlY3RvciIsInN1YnNjcmliZUZvclJlYWN0IiwicmVhY3RMaXN0ZW5lciIsImFjdHVhbENoaWxkUHJvcHMiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInN0YWNrIiwicmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50IiwicmVmIiwicmVuZGVyZWRDaGlsZCIsIlByb3ZpZGVyIiwiX0Nvbm5lY3QiLCJtZW1vIiwiQ29ubmVjdCIsIl9mb3J3YXJkZWQiLCJmb3J3YXJkQ29ubmVjdFJlZiIsImZvcndhcmRlZCIsImNvbm5lY3RfZGVmYXVsdCIsInByb3ZpZGVyUHJvcHMiLCJjaGlsZHJlbiIsInNlcnZlclN0YXRlIiwiYmFzZUNvbnRleHRWYWx1ZSIsImlkZW50aXR5RnVuY3Rpb25DaGVjayIsInN0YWJpbGl0eUNoZWNrIiwiYXNzaWduIiwicHJldmlvdXNTdGF0ZSIsIlByb3ZpZGVyX2RlZmF1bHQiLCJjcmVhdGVSZWR1eENvbnRleHRIb29rIiwidXNlUmVkdXhDb250ZXh0MiIsInVzZVJlZHV4Q29udGV4dCIsImNyZWF0ZVN0b3JlSG9vayIsInVzZVN0b3JlMiIsIndpdGhUeXBlcyIsInVzZVN0b3JlIiwiY3JlYXRlRGlzcGF0Y2hIb29rIiwidXNlRGlzcGF0Y2gyIiwidXNlRGlzcGF0Y2giLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciIsInJlZkVxdWFsaXR5IiwiY3JlYXRlU2VsZWN0b3JIb29rIiwidXNlU2VsZWN0b3IyIiwiZXF1YWxpdHlGbk9yT3B0aW9ucyIsImVxdWFsaXR5Rm4iLCJyZWR1eENvbnRleHQiLCJmaXJzdFJ1biIsIndyYXBwZWRTZWxlY3RvciIsInVzZUNhbGxiYWNrIiwic2VsZWN0ZWQiLCJkZXZNb2RlQ2hlY2tzIiwiZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2siLCJmaW5hbFN0YWJpbGl0eUNoZWNrIiwidG9Db21wYXJlIiwid2FybiIsInNlbGVjdGVkMiIsInNlbGVjdGVkU3RhdGUiLCJ1c2VEZWJ1Z1ZhbHVlIiwidXNlU2VsZWN0b3IiLCJiYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/react-redux/dist/react-redux.mjs\n");

/***/ })

};
;